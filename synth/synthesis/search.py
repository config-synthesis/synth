"""Search support for configuration synthesis."""


# Imports.
from collections import Counter
from collections.abc import Set
from dataclasses import dataclass
from textwrap import indent
from typing import Iterable, Optional, Union

from docker.types import Mount

from synth.logging import logger
from synth.synthesis import knowledge_base as kb
from synth.synthesis.classes import (
    ConfigurationChange,
    ConfigurationSystem,
    ConfigurationTask,
    ConfigurationTaskArgumentMapping,
    ConfigurationTaskError,
)
from synth.synthesis.docker import get_runner
from synth.synthesis.exceptions import UnresolvedTaskFailure


# Some configuration systems represent their tasks using a lower level system
# like shell commands. This dict records when that happens so that it can be
# used for lookup or interoperability with the knowledge base.
CONFIGURATION_SYSTEM_MAPPING = {
    ConfigurationSystem.DOCKER: ConfigurationSystem.SHELL,
}


@dataclass(frozen=True)
class SearchResult:
    """A single result from running search.

    Attributes
    ----------
    task : ConfigurationTask
        The configuration task discovered during search.
    changes : frozenset[ConfigurationChange]
        The changes that ``task`` covers from the initial set of desired
        changes.
    original_task : Optional[ConfigurationTask]
        The source task for ``task`` if it was generated by mapping. Must be
        set if ``mapping`` is set.
    mapping : Optional[ConfigurationTaskArgumentMapping]
        The mapping for ``original_task``. Must be set if ``original_task`` is
        set.
    """

    task: ConfigurationTask
    original_task: Optional[ConfigurationTask] = None
    mapping: Optional[ConfigurationTaskArgumentMapping] = None


def get_task_set(changes: Iterable[ConfigurationChange],
                 system:
                 Union[str, ConfigurationSystem] = ConfigurationSystem.SHELL,
                 level: Optional[int] = 1,
                 ) -> set[SearchResult]:
    """Find a set of tasks that reproduce a configuration.

    Parameters
    ----------
    changes : Iterable[ConfigurationChange]
        A collection of configuration changes to reproduce.
    system : Union[str, ConfigurationSystem]
        The target configuration system. Returned tasks will be fore the
        configuration system.
    level : Optional[int]
        Task level to use in search. If None, then all levels will be used.

    Returns
    -------
    set[SearchResult]
        A set of results that best covers ``changes``. This covering may be
        incomplete if there is no known task that covers a change.
    """
    logger.info('Searching for a configuration task set.')

    # Get the correct configuration system for underlying tasks.
    system = ConfigurationSystem(system)
    system = CONFIGURATION_SYSTEM_MAPPING.get(system, system)
    logger.verbose(
        f'Searching for tasks in the `{system}` configuration system.'
    )
    if level is not None:
        logger.verbose(f'Using task level `{level}`.')

    # Get all system tasks.
    system_tasks = kb.get_configuration_tasks(system, level=level)
    num_system_changes = sum(len(t.changes) for t in system_tasks)
    logger.verbose(
        f'Loaded `{len(system_tasks)}` system tasks with '
        f'`{num_system_changes}` total changes.'
    )

    # Init tracking variables. In order:
    # 1. All changes that have not yet been covered by some task.
    # 2. All tasks, covered changes, and mappings in the covering.
    # 3. All tasks that can contribute to the covering.
    uncovered_changes = set(changes)
    logger.verbose(f'{len(uncovered_changes)} uncovered changes')

    covering = set()

    applicable_tasks = set()
    for task in system_tasks:
        logger.verbose(
            f'Computing change intersection with {task}. '
            f'`{len(uncovered_changes)}` uncovered changes, '
            f'`{len(task.changes)}` task changes.'
        )
        change_intersection = ConfigurationChange.change_intersection(
            task.changes,
            uncovered_changes,
        )
        logger.verbose('Done.')
        if change_intersection[0]:
            applicable_tasks.add(task)

    # Immediately release system tasks for memory.
    del system_tasks

    # Log info.
    changes_str = indent('\n'.join(map(str, uncovered_changes)), prefix='    ')
    logger.spam(
        f'\n'
        f'Reproducing the Following Configuration Changes:\n'
        f'{changes_str}'
    )
    tasks_str = indent('\n'.join(map(str, applicable_tasks)), prefix='    ')
    logger.spam(f'\nApplicable Configuration Tasks:\n{tasks_str}')
    logger.verbose(f'`{len(applicable_tasks)}` applicable tasks.')

    # Search for the best covering.
    logger.verbose('Running search process.')
    while uncovered_changes:
        logger.verbose(f'{len(uncovered_changes)} left to cover')
        max_weight = 0
        max_weight_task: Optional[ConfigurationTask] = None
        max_weight_changes: Optional[set[ConfigurationChange]] = None
        max_weight_mapping: Optional[ConfigurationTaskArgumentMapping] = None

        # Search for the task that best covers the remaining changes.
        to_remove = set()
        for task in applicable_tasks:

            # Compute the intersection of the task's changes with all remaining
            # uncovered changes.
            logger.verbose(f'Evaluating task `{task}`.')
            intersection = ConfigurationChange.change_intersection(
                task.changes,
                uncovered_changes,
            )
            task_intersection, uncovered_intersection, mapping = intersection
            weight = len(task_intersection) / len(task.changes)
            logger.verbose(
                f'Task intersection has `{len(task_intersection)}` changes. '
                f'Task weight is `{len(task_intersection)} / '
                f'{len(task.changes)} ({weight})`'
            )

            if weight <= 0.001:
                # Remove the task if its weight is at most 1/1000. This means
                # it is not a very strong match for the remaining changes that
                # need to be covered.
                to_remove.add(task)
            elif weight > max_weight:
                max_weight = weight
                max_weight_task = task
                max_weight_changes = uncovered_intersection
                max_weight_mapping = mapping

        applicable_tasks -= to_remove

        # If such a task was found, add it to the covering. If no task was
        # found, then we cannot cover any of the remaining changes.
        if max_weight_task:
            logger.verbose(
                f'Selecting task `{max_weight_task}`. Task covers '
                f'`{len(max_weight_changes)}` changes.'
            )
            covering.add(SearchResult(
                task=max_weight_task.from_mapping(max_weight_mapping),
                original_task=max_weight_task,
                mapping=max_weight_mapping,
            ))
            uncovered_changes = uncovered_changes - max_weight_changes
        else:
            break

    logger.verbose('Done searching for a configuration cover.')

    # Warn about uncovered changes.
    if uncovered_changes:
        changes_str = indent(
            '\n'.join(map(str, uncovered_changes)),
            prefix='    ',
        )
        logger.spam(
            f'\n'
            f'Unable to find a task to cover changes:\n'
            f'{changes_str}'
        )

    return covering


def get_task_ordering(tasks: Set[SearchResult],
                      raise_on_unresolved: bool = False,
                      max_failures: int = 10,
                      image: Optional[str] = None,
                      is_runner_image: Optional[bool] = None,
                      mounts: Optional[list[Mount]] = None,
                      ) -> list[SearchResult]:
    """Get a runnable ordering of configuration tasks.

    In general, a some task B should come after another task A if B depends
    on one or more resources created (or modified/deleted) by A. However,
    this dependence can be non-trivial to infer. Take, for example, the
    following tasks:

    A. git clone <repo-url>
    B. cd <repo-dir>
    C. git checkout <commit-ish>

    The tasks must be run in the order A <= B <= C. You can probably infer
    A <= B by the fact that A will create <repo-dir>, which is necessary for
    B to set it as the working directory. However, it's less obvious how to
    infer B <= C. C only requires being inside of a directory with a `.git`
    subdirectory, and only implicitly.

    There are a couple different ways that we could do this:

    Option 1 (Implemented): Generate a best-effort ordering from the available
    information. Run the tasks in the best-effort order. If some task X
    fails, look up which tasks are needed to resolve it according to the
    error message. If any such tasks occur after X in the ordering, pull them
    forward, then add all other tasks from the lookup that did not appear in
    the ordering. Restart at the first added task. If the task fails in the
    same way the next time it's processed, then the error cannot be resolved.

    Option 1 (Backup/Improvement?): Trace the tasks to get a better
    understanding of the resources they try to interact with. Use this resource
    list to impose an ordering.

    Parameters
    ----------
    tasks : Set[SearchResult]
        A set of tasks discovered by search that produce configuration changes.
    raise_on_unresolved : bool
        If True, unresolved errors will raise an error. Otherwise,
        configuration tasks with unresolved errors will be dropped.
    max_failures : int
        The maximum number of times a task can fail before it is removed from
        consideration, even if no error is seen twice.
    image : str
        The Docker image to use for ordering.
    is_runner_image : bool
        Whether the base image is a Synth runner image.
    mounts : Optional[list[Mount]]
        Docker mounts to use during ordering.

    Returns
    -------
    list[SearchResult]
        An ordering of the tasks from ``tasks`` such that each task can be
        run successfully.
    """
    logger.info('Searching for a configuration task ordering.')
    # Create a best-effort ordering of configuration tasks. Right now this is
    # just the order of iteration, but in the future it could be based on any
    # heuristic that improves the likelihood of having a correct ordering.
    task_list = list(tasks)

    # If there are no tasks then there's nothing to order. Return the empty
    # task list. Note that we still run ordering on lists containing a single
    # task because the configuration failure resolution step could potentially
    # add new tasks to the list.
    if not task_list:
        return task_list

    # Activate the runner context.
    runner_kwargs = {}
    if image is not None:
        runner_kwargs['image'] = image
    if is_runner_image is not None:
        runner_kwargs['is_runner_image'] = is_runner_image
    if mounts is not None:
        runner_kwargs['mounts'] = mounts
    with get_runner(task_list[0].task.system, **runner_kwargs) as runner:

        # Container for all configuration task errors that have been
        # encountered. If the same error is encountered more than once, that
        # means the ordering process failed to resolve the error based on
        # `kb.get_resolving_tasks`.
        processed_task_errors: set[tuple[SearchResult,
                                         ConfigurationTaskError]] = set()

        # Counter for the number of times each task fails.
        num_failures = Counter()

        # Continue to perform the ordering process until all tasks in the list
        # have been ordered. Note that the list may potentially grow in size
        # during this step.
        idx = 0
        while idx < len(task_list):

            # Get the search result at the current index.
            result = task_list[idx]

            # Run the task against the runner.
            try:
                runner.run_task(
                    task=result.task,
                    arguments=result.task.configuration_task_arguments,
                )
            except ConfigurationTaskError as e:
                num_failures[result.task] += 1

                # If the result and error have been seen before, then the
                # ordering process has failed to resolve the error.
                processed_error = (result, e)
                if processed_error in processed_task_errors:
                    if raise_on_unresolved:
                        raise UnresolvedTaskFailure(
                            'Task error encountered twice. Failing.'
                        )
                    else:
                        logger.debug(
                            'Task error encountered twice. Dropping.'
                        )
                        task_list.pop(idx)
                        continue
                elif num_failures[result.task] == max_failures:
                    logger.debug(
                        'Task failed the maximum number of times. Dropping.'
                    )
                    task_list.pop(idx)
                    continue

                # Record the error.
                processed_task_errors.add(processed_error)

                # Ask the knowledge base for all tasks that could resolve the
                # error.
                logger.verbose('Searching for resolving tasks.')
                resolving_tasks = [
                    SearchResult(
                        task=task.from_mapping(mapping),
                        original_task=task,
                        mapping=mapping,
                    )
                    for task, mapping in kb.get_resolving_tasks(result.task, e)
                ]
                logger.verbose(
                    f'Found {len(resolving_tasks)} resolving tasks.'
                )
                # Begin constructing the new task list by inserting all
                # previous tasks followed by the just discovered resolving
                # tasks.
                old_task_list = task_list
                task_list = old_task_list[:idx] + resolving_tasks

                # For all future tasks, either insert them at the location of
                # a prior resolving task or append them to the end of the task
                # list. If the task is moved up, the overwrite makes sure the
                # resolving task covered changes are correct.
                resolving_idx_lookup = {
                    result.task: idx
                    for idx, result in enumerate(resolving_tasks)
                }
                for future_idx in range(idx + 1, len(old_task_list)):
                    future_result = old_task_list[future_idx]
                    future_task = future_result.task.no_changes()

                    if future_task in resolving_idx_lookup:
                        resolving_idx = resolving_idx_lookup[future_task]
                        task_list[idx + resolving_idx] = future_result
                        resolving_idx_lookup.pop(future_task)
                    else:
                        task_list.append(future_result)

                # Append the failed task to the end of the task list. If any
                # other task in the ordering is required but was not in the
                # resolving task list, this will result in the other task being
                # executed first.
                task_list.append(result)
            else:
                # If the task succeeded, then everything that came before in
                # the ordering must have been sufficient for it. Leave it where
                # it is in the ordering and move on to the next task.
                idx += 1
                logger.debug('Task succeeded.')

        return task_list
